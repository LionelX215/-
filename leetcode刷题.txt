# 1.两数求和
# 解法1：字典，时间复杂度O(n)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for index, number in enumerate(nums):
            res = target-number
            if res in dic.keys():
                return [dic[res], index]
            dic[number] = index
        return []
# 解法2：先排序，然后首尾靠近，时间复杂度O(nlogn)
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        sorted_id = sorted(range(len(nums)), key=lambda k: nums[k])
        # 返回的是index的值，将range(len(nums))按照nums的大小顺序进行排序
        head = 0
        tail = len(nums) - 1
        sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]
        while sum_result != target:
            if sum_result > target:
                tail -= 1
            elif sum_result < target:
                head += 1
            sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]
        return [sorted_id[head], sorted_id[tail]]


# 2.两数相加
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        carry = 0
        res = []
        while (l1 or l2):
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            temp = carry + x + y
            carry = temp//10
            temp = temp%10
            res.append(temp)
            l1 = l1.next if l1 else l1
            l2 = l2.next if l2 else l2
        if carry>0:
            res.append(1)
        return res


# 3.无重复字符的最长子串
# 解法：定义头尾指针，没有就重复就尾指针后移且长度+1，有重复就从头指针后移且删除第一个。~~
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if s == '':
            return 0
        max_l = 1
        temp_l = 1
        list_l = [s[0]]
        head  = 0
        tail = 1
        while tail<len(s):
            if s[tail] not in list_l:
                list_l.append(s[tail])
                tail += 1
                temp_l += 1
                max_l = temp_l if max_l<temp_l else max_l
            else:
                list_l.pop(0)
                head += 1
                temp_l -= 1
        return max_l

# 4. 从尾到头打印链表
# 解法：list存链表值，倒序输出。
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        node = listNode
        res = []
        while node:
            res.append(node.val)
            node = node.next
        res = res[::-1]
        return res

# 5.最长回文子串
# 解法1：暴力法，超时！
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if s=='':
            return ''
        else:
            max_l = 1
            res = s[0]
            for i in range(len(s)-1):
                for j in range(len(s)):
                    temp = s[i:j+1]
                    if temp == temp[::-1]:
                        if len(temp)>max_l:
                            max_l = len(temp)
                            res = temp
                    else:
                        continue
            return res
# 解法2：从左到右找，每个都找左右是否匹配。两种情况，一种是中间一个，两边匹配，还有一种是中间两个一样，两边匹配。
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if s=='':
            return ''
        max_l = 1
        res_str = s[0]
        for i in range(len(s)):
            str_1, l_1 = self.is_huiwen(s, i, i)
            # 以i为中心，左右匹配
            str_2, l_2 = self.is_huiwen(s, i, i+1)
            # i和i+1相同，然后以i和i+1中间的空隙为中间开始左右匹配
            cur_str = str_1 if l_1>l_2 else str_2
            if len(cur_str)>max_l:
                max_l = len(cur_str)
                res_str = cur_str
        return res_str
    def is_huiwen(self, s, left, right):
        while left>=0 and right<len(s) and s[left]==s[right]:
            left -= 1
            right += 1
        return s[left+1:right], right-left-1

# 6. Z字形变换
# 解法：Z型是有空位置的，其实空位并不影响，因为不用输出，所以可以直接上下一直循环着放就行了。
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if s=='':
            return ''
        if numRows==1:
            return s
        res = ''
        col = 0
        total_list = [[] for i in range(numRows)]
        for x in s:
            if col==(numRows-1):
                direction = -1
            elif col==(0):
                direction = 1
            total_list[col].append(x)
            if direction == 1:
                col += 1
            else:
                col -= 1
        for i in total_list:
            for j in i:
                res = res + j
        return res

# 7. 整数反转
# 解法：转str然后[::-1]。正负数就三目运算加符号就行了。 比较坑的是有大小范围，反转之后的超出和反转前超出都要返回0。
class Solution:
    def reverse(self, x: int) -> int:
        if x>=(-2)**31 and x<=((2**31)-1):
            res = int(str(x)[::-1]) if x>=0 else -int(str(abs(x))[::-1])
            return res if res>=(-2)**31 and res<=((2**31)-1) else 0
        else:
            return 0

# 8. 字符串转换整数
# 解法：这个题描述很复杂，其实就是用re。 注意一下解包，第一次遇到。
class Solution:
    def myAtoi(self, str: str) -> int:
        return max(min(int(*re.findall('^[\+\-]?\d+', str.lstrip())), 2**31 - 1), -2**31)
# 解包：first,*new, end=[94,85,73,46]    new --> [85, 73]          *[1] 报错    print(*[1]) ---> 1
# *[XXX]  必须要有调用  没有调用就会报错，比如上行print调用了他的结果。        findall会返回list（上面的程序只会返回一个值），
# 没找到会返回[]，解包后就是空格 空   int(空格)会返回0      解包的*类似传参的*和**

# 9. 回文数
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return str(x)[::-1]==str(x)     # 题目要求返回True或False，不用返回数。

# 11. 盛最多水的容器
# 解法：我们理一下思路，大小是由长度和高度决定，如果选 0 到 8 就保证了长度最长，此时大小是 0 号柱子的高度 1 乘以长度 8 。
# 我们如果想面积更大怎么做呢，只能减小长度，增加高度。是左边的柱子向右移动变成 1 号柱子呢？还是右边的柱子向左移动变成 7 号柱子呢？
# 当然是哪边的柱子短就改哪边的！只有这样，高度才有可能增加。
# 例如我们如果把 8 号柱子变成 7 号柱子，此时长度减少了，然而高度还是 0 号柱子没有变化，所以面积就会减少。把 1 号柱子变成 2 号柱子
# 就很好了，因为此时高度就变成了 8 号柱子的高度，面积就有可能会增加。
# 如果左右两边柱子相等该怎么办呢？随意！
# 我们假设 1 号 和 8 号 柱子高度是相等的。如果他们之间的柱子只有 1 根比它俩高或者没有比它俩高的，那么最大面积就一定选取是 1 号和 8 号
# 了，所以 1 号接着变大，或者 8 号接着减小都是无所谓的，因为答案已经确定了。
# https://leetcode-cn.com/problems/container-with-most-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-14/
# 低的要换，高的不动。因为如果低的可能换成高的，而高的就算换到更高的，面积还是按照低的去算，不会有变化的。
# 移动使长度变短了，只有高度变高才有可能增加面积，而高度是由低的那个决定的，所以只能换低的。
class Solution:
    def maxArea(self, height: List[int]) -> int:
        head = 0
        tail = len(height) - 1
        area = []
        while head<tail:
            side = tail - head
            temp_res = side*height[tail] if height[head]>=height[tail] else side*height[head]
            area.append(temp_res)
            if height[head]>=height[tail]:
                tail -= 1
            else:
                head += 1
        return max(area)

# 12. 整数转罗马数字
# 解法：从大到小找，比当前大的就可以从列表中删掉不再找了。
class Solution:
    def intToRoman(self, num: int) -> str:
        x_list = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
        t_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        res = ''
        while num>0:
            for j in range(len(x_list)):
                if num>=t_list[j]:
                    num -= t_list[j]
                    res += x_list[j]
                    if j!=0 or num>=t_list[j]:
                        x_list = x_list[j:]
                        t_list = t_list[j:]
                        break
        return res
# 解法2：别人的解法  思路是一样的，只不过更快应该，用除法，当比查询值大时，看看大几倍，就直接输出几个，然后继续迭代下一个查询值。
class Solution:
    def intToRoman(self, num: int) -> str:
        lookup = {1:'I',4:'IV',5:'V',9:'IX',10:'X',40:'XL',50:'L',90:'XC',100:'C',400:'CD',500:'D',900:'CM',1000:'M'}
        res = ""
        for key in sorted(lookup.keys())[::-1]:
            a = num // key
            if a == 0:      # 只有比查询值小才会跳过if     比num大就直接循环到下一个查询值了
                continue
            res += (lookup[key] * a)
            num -= a * key
            if num == 0:
                break
        return res

# 13. 罗马数字转整数
# 解法：还是按顺序读，如果没有特殊(IV,CM等)，那么前一个比后一个大，如果出现不是这样的，就把两位换成数字。
# 注意的是到倒数第二个如果不是特殊的，最后一位不是特殊，所以特殊判断的index到倒数第二位就可以了。
class Solution:
    def romanToInt(self, s: str) -> int:
        dic = {'M':1000, 'CM':900, 'D':500, 'CD':400, 'C':100, 
                  'XC':90, 'L':50, 'XL':40, 'X':10, 'IX':9, 'V':5, 
                  'IV':4, 'I':1}
        i = 0
        res = 0
        while i<len(s):
            if i<len(s)-1 and dic[s[i]]<dic[s[i+1]]:
                res += dic[s[i]+s[i+1]]
                i += 2
            else:
                res += dic[s[i]]
                i += 1
        return res
# 解法2：这个没写，其实差不多，按照两位两位的读，如果两位在字典中，就转数字然后往后两个。不在字典就读第一个然后往后移一位后，再读两个。

# 14. 最长公共前缀
# 解法：选出max和min的，然后按位对比，碰到不同就输出，如果全都相同最后循环完毕输出整个字符。
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if strs==[]:
            return ''
        t_1 = max(strs)
        t_2 = min(strs)
        res = ''
        if t_1=='' or t_2=='':
            return ''
        for i,x in enumerate(t_2):
            if x != t_1[i]:
                return t_1[:i]
        return t_2

# 15. 三数之和
# 解法： 先排序，然后循环选出第一个数，双指针，里面两个数相加等于第一层的数。需要注意的是去重复，当有重复数字时，会输出重复结果，首先在第一层
# 中，判断是否跟上一个相同，相同就直接跳过。里面指针部分，头尾移动，然后判断是否跟上一步的数字一样，一样就跳过。如果用 in 查询是否重复，时间复杂度不够。
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        for i in range(len(nums)-2):
            if nums[i]==nums[i-1] and i>0: continue
            head = i+1
            tail = len(nums)-1
            while head<tail:
                if nums[head]+nums[tail]==(-nums[i]):
                    res.append([nums[head], nums[tail], nums[i]])
                    head += 1
                    tail -= 1
                    while nums[head-1]==nums[head] and head<tail: head += 1
                    while nums[tail+1]==nums[tail] and head<tail: tail -= 1
                elif nums[head]+nums[tail]<(-nums[i]):
                    head += 1
                    while nums[head-1]==nums[head] and head<tail: head += 1
                else:
                    tail -= 1
                    while nums[tail+1]==nums[tail] and head<tail: tail -= 1
        return res

# 16. 最接近的三数之和
# 解法： 跟上面的思路一样，先判断是否更新最接近的值，然后如果目前的求和大于target，就尾移动，如果小于就头移动，如果相等就直接输出。
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        res = nums[0]+nums[1]+nums[2]
        for i in range(len(nums)-2):
            a = nums[i]
            y = i + 1
            z = len(nums) - 1
            while y<z:
                b = nums[y]
                c = nums[z]
                add = a + b + c
                if abs(add-target) < abs(res-target):
                    res = add
                if add<target:
                    y += 1
                elif add>target:
                    z -= 1
                else:
                    return target
        return res 

# 20. 有效的括号
# 解法： List当做栈结构，左括号进栈，右括号看前一个是不是对应的左括号。注意的是当temp为空，来了右括号就直接返回False了。
# 还有就是最终循环完要看temp是不是空，因为全是左括号也不会到return False那一行。
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {')':'(', ']':'[', '}':'{'}
        temp = []
        for i,x in enumerate(s):
            if x in dic.values():
                temp.append(x)
            else:
                if temp!=[] and temp[-1]==dic[x]:
                    temp.pop()
                else:
                    return False
        return temp==[]

# 142. 环形链表II
# 解法1：创建列表，发现重复的node的时候输出就是环形的开头位置，如果为None重复就证明没有环形，输出null
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        l = [None]
        while head:
            if head not in l:
                l.append(head)
            else:
                return head
            head = head.next

# 解法2：快慢指针，快指针走2，慢指针走1，设环的起始节点为 E，快慢指针从 head 出发，快指针速度为 2，设相交节点为 X，head 到 E 的距离为 H，
# E 到 X 的距离为 D，环的长度为 L，那么有：快指针走过的距离等于慢指针走过的距离加快指针多走的距离（多走了 n 圈的 L）
# 2(H + D) = H + D + nL，因此可以推出 H = nL - D(这里nL和L一样，因为多走一圈还是回到这个位置)，这意味着如果我们让俩个慢指针一个从 head 出发，
# 一个从 X 出发的话，他们一定会在节点 E 相遇
class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        while True:
            if not (fast and fast.next): return
            fast, slow = fast.next.next, slow.next
            if fast == slow: break
        fast = head
        while fast != slow:
            fast, slow = fast.next, slow.next
        return fast

# 204. 计算质数
# 解法1：用常规的先写循环拿出2,n的所有数，然后每个数都计算是不是质数，是就记录。这种没错，但是会超出内存限制。
# 解法2：先存个列表True，长度为n的长度，然后按顺序从2开始拿，如果是2的倍数就置位False，然后循环3，....
class Solution(object):
    def countPrimes(self, n):
        d=[True]*n
        count=0
        for i in range(2,n):
            if d[i]:
                count+=1
                for j in range(i,n,i):
                    d[j]=False
        return count

# 226. 翻转二叉树
# 解法：大神说二叉树的算法大部分都是递归做。左右互换，迭代，终止条件就是为None，每轮root的左右互换，所以返回的是root。
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root is None:
            return
        root.right,root.left=self.invertTree(root.left),self.invertTree(root.right)
        return root 






























剑指offer:
# 1. 二叉树镜像
# 解法：左右互换递归。注意，如果不定义临时变量需要左右同时互换，不然会出错。
# (1). 不定义临时变量
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if root is None:
            return 
        root.right, root.left = self.Mirror(root.left), self.Mirror(root.right)
        return root
# (2). 定义临时变量
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if root is None:
            return 
        root.right, root.left = root.left, root.right
        root.right = self.Mirror(root.left)
        root.left = self.Mirror(root.right)
        return root

# 2. 链表中环的入口节点
# 解法：都存到列表中，第一个重复的就是环的入口。
class Solution:
    def EntryNodeOfLoop(self, pHead):
        # write code here
        l = [None]
        while pHead:
            if pHead not in l:
                l.append(pHead)
            else:
                return pHead
            pHead = pHead.next
        return pHead

# 3.删除链表中重复的结点      Leetcode 82
# 解法：双指针，一个从head开始，一个从head前面自建节点开始，如果不相同，就同时向后一位；如果相同就while循环，head和head.next不相同时
# 返回head.next，这时head.next到pre之间的都是重复元素，之间将pre.next指向head.next就完成。return的是建立的节点的Next,注意while的值。
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        res = ListNode(-111)
        res.next = head
        pre = res
        while head and head.next:
            if head.val == head.next.val:
                while head.next:
                    if head.next.val == head.val:
                        head = head.next
                    else:
                        break
                pre.next = head.next
            else:
                pre = pre.next
            head = head.next
        return res.next

# 4. 从尾到头打印链表
# 解法：list存链表值，倒序输出。
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        node = listNode
        res = []
        while node:
            res.append(node.val)
            node = node.next
        res = res[::-1]
        return res

# 5. 斐波那契
# 解法: (1)递归。  (2)先存入011三个特殊的，然后通过循环，每个新的append都是前两个的求和。
# 递归        OJ的内存超出限制了
def Fibonacci(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return Fibonacci(n-1)+Fibonacci(n-2)
# 循环
class Solution:
    def Fibonacci(self, n):
        a = [0,1,1]
        if n<3:
            return a[n]
        for i in range(3,n+1):
            a.append(a[-1] + a[-2])
        return a[n]

# 6. 跳台阶
# 解法：跟斐波那契一样，每次都是跳1或者2台阶，那么就等于本身-1的后的可能性和本身-2的可能性。

# 7. 变态跳台阶
# 解法:  延续上一题的思路，逆向思维来考虑这个问题。想跳到第n级台阶，就从第n-1级、第n-2级、***、第1级 跳到第n级，再加上直接从地面到第n级的一种情况。
class Solution:
    def Fibonacci(self, n):
        if n<=2:
            return n
        add = 3
        for i in range(n-2):
            temp = add + 1
            add += temp
        return temp

# 8. 矩阵覆盖
# 解法： 一样还是f(n) = f(n-1)+f(n-2)
class Solution:
    def rectCover(self, number):
        # write code here
        a = [0,1,2]
        if number<=2:
            return a[number]
        for i in range(3,number+1):
            a.append(a[-1]+a[-2])
        return a[number]

# 9. 把字符串转换成整数
# 解法：先判断字符串长度，为空为1的情况。然后一般情况先判断第一个字符是否是非数字，+ - 和其他字母操作不同。后面的只需要判断是不是数字就可以了。
class Solution:
    def StrToInt(self, s):
        # write code here
        if s=='':
            return 0
        lis = ['0','1','2','3','4','5','6','7','8','9']
        if len(s)==1 and s not in lis:
            return 0
        nums = ''
        for index, strs in enumerate(s):
            if index==0:
                if strs in lis or strs=='-':
                    nums += strs
                elif strs=='+':
                    continue
                else:
                    return 0
            else:
                if strs in lis:
                    nums += strs
                else:
                    return 0
        return int(nums)

# 10. 平衡二叉树
# 解法：计算节点深度，自上而下，空树也是平衡二叉树，分别计算左右节点的高度，超过1时直接可以输出不是平衡二叉树，如果不超过1就迭代左右节点。
# 注意初始化深度，如果子树为空，那么他的高度就是0
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def IsBalanced_Solution(self, pRoot):
        # write code here
        if pRoot is None:
            return True
        # 定义左右树的高度，如果左右树为空，就高度就为0
        left_depth = self.get_depth(pRoot.left) if pRoot.left else 0
        right_depth = self.get_depth(pRoot.right) if pRoot.left else 0
        if abs(left_depth - right_depth)>1:
            return False
        else:
            return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
    def get_depth(self, root):
        if root is None:
            return 0
        return max(self.get_depth(root.left), self.get_depth(root.right))+1

# 11. 和为S的连续正数序列
# 解法：穷举，循环每个数字作为开头，然后从每个开头开始计算不同长度的求和是多少，大于就break直接跳出循环。
# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        res = []
        for i in range(1, tsum-1):
            temp_sum = i
            for j in range(i+1, tsum):
                temp_sum += j
                if temp_sum==tsum:
                    res.append([k for k in range(i, j+1)])
                elif temp_sum>tsum:
                    break
        return res

# 12. 左旋转字符串
# 解法：移位其实就是：(需要移位的翻转 + 不移位的翻转)翻转
class Solution:
    def LeftRotateString(self, s, n):
        # write code here
        s = (s[0:n][::-1] + s[n:][::-1])[::-1]
        return s

# 13. 数字在排序数组中出现的次数
# 解法： 有人用二分查找。  data.count(k) 最快
class Solution:
    def GetNumberOfK(self, data, k):
        # write code here
        res = 0
        for i in data:
            if i==k:
                res += 1
            elif i>k:
                break
        return res

# 14. 数组中只出现一次的数字
# 解法：存成字典。
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
    # write code here
        res = {}
        for i in array:
            if i not in res.keys():
                res[i] = 1
            else:
                res[i] += 1
        alone = []
        for keys, values in res.items():
            if values==1:
                alone.append(int(keys))
        return alone

# 15. 翻转单词顺序列
# 解法：空格分段，翻转后再拼接。   注意：split(' ') 默认是所有空字符串，包括换行等。  不写' '时不能AC，在输入' '时不对
def ReverseSentence(self, s):
    # write code here
    return ' '.join(s.split(' ')[::-1])

# 16. 二叉树深度
# 解法： 看见二叉树先考虑递归。 左右子树最大高度加1就是目前节点的高度。终止条件为节点深度为0，即None。
def TreeDepth(self, pRoot):
    # write code here
    if pRoot is None:
        return 0
    return max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right))+1

# 17. 和为S的两个数字
# 解法：双指针。 多个答案输出乘积最小的：定义一个临时变量存储最小的值和对应的index
class Solution:
    def FindNumbersWithSum(self, array, tsum):
        # write code here
        res = []
        begin = 0
        end = len(array)-1
        while begin<end:
            if array[begin] + array[end] > tsum:
                end -= 1
            elif array[begin] + array[end] < tsum:
                begin += 1
            else:
                res.append([array[begin], array[end]])
                end -= 1
                begin += 1
        if len(res)==1:
            return res[0]
        elif res==[]:
            return []
        else:
            index = 0
            j = res[0][0] * res[0][1]
            for i in range(len(res)):
                temp = res[i][0] * res[i][1]
                if temp<j:
                    j = temp
                    index = i
        return res[index]

# 18. 顺时针打印矩阵
# 解法：看代码。思路清晰，编写比较难。
def printMatrix(matrix):
    if not matrix:
        return []
    res = []
    row = len(matrix)
    col = len(matrix[0])
    circle = (min(row, col) - 1) // 2 + 1
    left, top, right, buttom = 0, 0, col - 1, row - 1
    for i in range(circle):
        for j in range(left, right + 1):
            res.append(matrix[i][j])
        for j in range(top + 1, buttom + 1):
            res.append(matrix[j][right])
        if top != buttom:
            for j in range(right - 1, left - 1, -1):
                res.append(matrix[buttom][j])
        if left != right:
            for j in range(buttom - 1, top, -1):
                res.append(matrix[j][left])
        left += 1
        right -= 1
        top += 1
        buttom -= 1
    return res

# 19. 对称的二叉树
# 解法：有迭代和递归两种做法。迭代就是宽度优先搜索，然后查看每层是否是回文数。
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        def check(node1, node2):
            if not node1 and not node2:
                return True
            elif not node1 or not node2:
                return False
            if node1.val != node2.val:
                return False
            return check(node1.left, node2.right) and check(node1.right, node2.left)
        return check(root.left, root.right)

# 20. 二叉树的下一个节点
# 解法：三种情况：如果pNode为空，直接返回。 因为是中序的下一个节点，如果pNode存在右孩子，那么它的下一个一定是右孩子最左的节点。
# 最后一种情况是pNode没有右孩子，它是它的父节点的左孩子或者右孩子，如果是它父节点的左孩子，那么下一个节点就是它的父节点，如果它
# 是它的父节点的右孩子，那它的下一个节点就是它父节点的父节点。 最后一个return表示，它是遍历的最后一个节点，没有下个节点了。
# 比如只有三个节点的树的，右孩子的下一个节点就是None，经过代码中的循环都退出且没有返回。
# class TreeLinkNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.next = None
class Solution:
    def GetNext(self, pNode):
        if not pNode:
            return 0
        elif pNode.right:
            pNode = pNode.right
            while pNode.left:
                pNode = pNode.left
            return pNode
        else:
            while pNode.next:
                if pNode == pNode.next.left:
                    return pNode.next
                pNode = pNode.next
        return None

# 21. 把二叉树打印成多行
# 解法：在广度优先算法的基础上修改。因为输出格式的要求，所以多定义了几个临时变量，每一层都单独存储节点，用for循环读取每个节点的下层节点。
#  广度优先算法代码。
def Print(self, pRoot):
    # write code here
    if not pRoot:
        return pRoot
    stack = []
    stack.append(pRoot)
    res = []
    while stack:
        cur = stack.pop(0)
        res.append(cur.val)
        if cur.left:
            stack.append(cur.left)
        if cur.right:
            stack.append(cur.right)
    return res
# 问题解决
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def Print(self, pRoot):
        # write code here
        if pRoot is None:
            return []
        stack = []
        stack.append(pRoot)
        res = []
        while stack:
            temp_sta = []
            temp = []
            for node in stack:
                temp.append(node.val)
                if node.left:
                    temp_sta.append(node.left)
                if node.right:
                    temp_sta.append(node.right)
            res.append(temp)
            stack = temp_sta
        return res

# 22. 按之字形顺序打印二叉树
# 解法：在上一题的基础上，添加level信息，当level为偶数时将记录的节点信息反向。
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def Print(self, pRoot):
        # write code here
        if pRoot is None:
            return []
        stack = []
        stack.append(pRoot)
        res = []
        level = 1
        while stack:
            temp_sta = []
            temp = []
            for node in stack:
                temp.append(node.val)
                if node.left:
                    temp_sta.append(node.left)
                if node.right:
                    temp_sta.append(node.right)
            temp = temp if level%2==1 else temp[::-1]
            level += 1
            res.append(temp)
            stack = temp_sta
        return res

# 23. 二叉树序列化和反序列化
# 解法：用哪种遍历都可以，先序可以递归。 我用广度优先算法。序列化是给树返回出[1,2,3,n,n,6,7]。反序列化是'1 2 3 n n 6 7'返回出树。
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def Serialize(self, root):
        # write code here
        queue = [root]
        res = []
        while queue:
            cur = queue.pop(0)
            if cur:
                res.append(str(cur.val))
                queue.append(cur.left)
                queue.append(cur.right)
            else:
                res.append('n')
        return ' '.join(res)

    def Deserialize(self, s):
        # write code here
        tree = s.split()
        if tree[0]=='n':
            return None
        root = TreeNode(int(tree[0]))
        queue = [root]
        i = 1
        while queue:
            cur = queue.pop(0)
            if cur is None:
                continue
            cur.left = TreeNode(int(tree[i])) if tree[i] != 'n' else None
            cur.right = TreeNode(int(tree[i+1])) if tree[i+1] != 'n' else None
            i += 2
            queue.append(cur.left)
            queue.append(cur.right)
        return root

# 24. 二叉树的第k个节点
# 解法：中序遍历正好是第k个。  在这我用的方法是层序遍历然后排序选取第k个，牛客不通过，给的数据格式不同。leetcode可以通过
# 中序遍历：
class Solution:
    # 返回对应节点TreeNode
    def KthNode(self, pRoot, k):
        # write code here
        stack = []
        node = pRoot
        while node:
            stack.append(node)
            node = node.left
        cnt = 1
        while(stack and cnt<=k):
            node = stack.pop()
            right = node.right
            while right:
                stack.append(right)
                right = right.left
            cnt+=1
        if node and k==cnt-1:
            return node
        return None
# 广度优先：
class Solution(object):
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        queue = [root]
        res = []
        while queue:
            cur = queue.pop(0)
            res.append(cur.val)
            if cur.left:
                queue.append(cur.left)
            if cur.right:
                queue.append(cur.right)
        res.sort()
        if k<1 or k>len(res):
            return None
        return res[k-1]

# 25. 数据流中的中位数
# 解法：每次来新的数据，从头开始挨个比较大小，找到合适位置记录，然后插入数据。查询时，奇数为中点，偶数为[中点+(中点-1)]/2.0  /2.0不损失精度
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.lis = []

    def Insert(self, num):
        # write code here
        length = len(self.lis)
        i=0
        while i<length:
            if num<self.lis[i]:
                break
            i += 1
        self.lis.insert(i, num)

    def GetMedian(self, x):
        # write code here
        length = len(self.lis)
        res = self.lis[length//2] if length%2 != 0 else (self.lis[length//2]+self.lis[length//2-1])/2.0
        return res

# 26. 重建二叉树
# 解法：标准的递归结构。 拿出前序的第一个节点，就是中间节点，将中序分为左子树和右子树。每层任务是找到自己的节点和自己子节点，返回自己节点。
# 关于i的取值，中序的第i个是中点，在前序的前i个都是左子树的节点值。可以画个前中序看看。
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if not pre:
            return None
        
        x = pre.pop(0)
        node = TreeNode(x)
        i = tin.index(x)
        
        node.left = self.reConstructBinaryTree(pre[:i],tin[:i])
        node.right = self.reConstructBinaryTree(pre[i:], tin[i+1:])
        
        return node

# 27. 滑动窗口的最大值
# 解法：左滑max取最大。
class Solution:
    def maxInWindows(self, num, size):
        # write code here
        if size<1:
            return []
        res = []
        for i in range(len(num)-size+1):
            res.append(max(num[i:i+size]))
        return res

# 28.用两个栈实现队列操作
# 解法：队列先进先出，进append，出pop(0)
class Solution:
    def __init__(self):
        self.stack = []
    def push(self, node):
        # write code here
        self.stack.append(node)
    def pop(self):
        # return xx
        return self.stack.pop(0)

# 29. 旋转数组的最小数字
# 解法：找到旋转位置，然后前面翻转后面翻转再整体翻转，第一个元素就是目标元素。
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        n = len(rotateArray)
        if n==0:
            return 0
        i=0
        while i<n:
            if rotateArray[i]>rotateArray[i+1]:
                break
            i += 1
        lis = (rotateArray[0:i+1][::-1] + rotateArray[i+1:][::-1])[::-1]
        return lis[0]

# 30. 丑数
# 解法：1是丑数，所以1的2,3,5倍是丑数，同理，后面的也都是他们的2,3,5倍。为了按顺序排(不按照顺序排有可能第n个是错的，因为可能有小的在后面还没算到)
# 比如1,2,3,5 但是第4个应该是2*2=4。 还有就是需要消除重复元素，2*3=3*2。 定义了三个index，记录的时当前index的数与2,3,5的乘积是否已经放入了list中，
# 如果已经放入了，就证明这个index的值对于自己(2,3,5)已经乘过了，就可以计算下一个值的倍数了。 重复的值会都消除，比如6，会使index_2和index_3都增。
# 只要能够整除，就证明这个数已经使用了。
class Solution:
    def GetUglyNumber_Solution(self, index):
        # write code here
        if index==0:
            return 0
        lis = [1]
        two_index = 0
        three_index = 0
        five_index = 0
        for i in range(index-1):
            nums = min(lis[two_index]*2, lis[three_index]*3, lis[five_index]*5)
            lis.append(nums)
            if nums%2==0:
                two_index += 1
            if nums%3==0:
                three_index += 1
            if nums%5==0:
                five_index += 1
        return lis[-1]

# 31. 两个链表的第一个公共节点
# 解法：将第一个的存入list中，然后第二个找相同的。    总感觉牛客里面定义的节点有点问题。
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        list_1 = []
        list_2 = []
        node_1 = pHead1
        node_2 = pHead2
        while node_1:
            list_1.append(node_1.val)
            node_1 = node_1.next
        while node_2:
            if node_2.val in list_1:
                return node_2
            node_2 = node_2.next
        return None

# 32. 第一个只出现一次的字符
# 解法：循环一遍字符串，字符存入字典，再遍历字符串，找到第一个计数为1的字符。
class Solution:
    def FirstNotRepeatingChar(self, s):
        # write code here
        dic = {}
        for i in s:
            if i not in dic.keys():
                dic[i] = 1
            else:
                dic[i] += 1
        for index, k in enumerate(s):
            if dic[k] == 1:
                return index
        return -1

# 33. 数组中的逆序对
# 解法：归并，从后面数组先拿出的数据，在count加上此时前面数组剩下的数字的个数，就是排在他前面比他大的个数。
class Solution:
    """
        目前三种方法
        冒泡排序并count+=1复杂度太高
        将数组先排好序再从原数组中找到每个数的位置相加并移除的方法，也是复杂度太高
        使用归并排序并count+=1可以
    """
    def InversePairs(self, data):
        # write code here
        return self.inverseCount(data[:], 0, len(data)-1, data)%1000000007
      
    def inverseCount(self, tmp, start, end, data):
        if end-start <1:
            return 0
        if end - start == 1:
            if data[start]<=data[end]:
                return 0
            else:
                tmp[start], tmp[end] = data[end], data[start]
                return 1
        mid = (start+end)//2
        cnt = self.inverseCount(data, start, mid, tmp) + \
                self.inverseCount(data, mid+1, end, tmp)
        # print(start, mid, end, cnt, data)
        i = start
        j = mid + 1
        ind = start
          
        while(i <= mid and j <= end):
            if data[i] <= data[j]:
                tmp[ind] = data[i]
                i += 1
            else:
                tmp[ind] = data[j]
                cnt += mid - i + 1
                j += 1
            ind += 1
        while(i<=mid):
            tmp[ind] = data[i]
            i += 1
            ind += 1
        while(j<=end):
            tmp[ind] = data[j]
            j += 1
            ind += 1
        return cnt

# 34. 连续子数组的最大和
# 解法：如果前面的大于0，就继续和，小于0就舍弃，直接计算新的。  记得每次都要更新最大值，不能只等大于0才更新，比如-5,-2 最大是-2。
def FindGreatestSumOfSubArray(array):
    # write code here
    num_max = array[0]
    num_sum = array[0]
    for i in array[1:]:
        if num_sum>0:
            num_sum += i
        else:
            num_sum = i
        num_max = num_sum if num_sum > num_max else num_max
    return num_max

# 35. 最小的K个数
# 解法：排序。
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
        # write code here
        if k > len(tinput):
            return []
        lis = list(set(tinput))
        lis.sort()
        return lis[:k]

# 36. 数组中出现次数超过一半的数字
# 解法：存字典，然后找values超过一半的keys。
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        # write code here
        dic = {}
        for i in numbers:
            if i in dic:
                dic[i] += 1
            else:
                dic[i] = 1
        for keys, vals in dic.items():
            if vals > (len(numbers)//2):
                return int(keys)
        return 0

# 37. 整数中1出现的次数（从1到n整数中1出现的次数）
# 解法：首先，整体出现的次数就是求和的过程，比如n=1200， 那么就是 1-9 出现的次数 + 10-99 出现的次数 + 100-999出现的次数 + 1000-1200出现的次数。
# 这里所说的每一位不是在n上的每一位，而是n之前的某些数。 所以n中出现的就是前面出现的次数的和。
# ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，...，
# 11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。
# ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,
# 2100~2199，，....，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位
# 出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。
# ③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，...，11100~11199,
# 12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        # write code here
        base = 1
        temp = n
        res = 0
        while temp:
            last = temp%10
            temp = temp / 10
            if last == 0:
                res += temp * base
            elif last == 1:
                res += (temp * base) + (n % base) + 1
            else:
                res += (temp+1) * base
            base *= 10
        return res

# 38. 把数组排成最小的数
# 解法：按照冒泡的方式，两个字符组合AB和BA判断大小，移动数值位置。
class Solution:
    def PrintMinNumber(self, numbers):
        # write code here
        for i in range(len(numbers)-1):
            for j in range(len(numbers)-i-1):
                cmp_1 = str(numbers[j]) + str(numbers[j+1])
                cmp_2 = str(numbers[j+1]) + str(numbers[j])
                if int(cmp_1) > int(cmp_2):
                    numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
        temp = [str(i) for i in numbers]
        return ''.join(temp)

# 39. 数组中重复的数字
# 解法：字典，重复就返回。
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        # write code here
        dic = {}
        for i in numbers:
            if i not in dic.keys():
                dic[i] = 1
            else:
                duplication[0]=i
                flag = True
                return True
        return False

# 40. 构建乘积数组
# 解法：每个值都是它左边的乘积和右边的乘积的乘积，那么可以分别计算左边的乘积和右边的乘积，存为list，每个位置的乘积都是上一个乘积乘上新的值。
# 比如 B[i] = B[i-1] * A[i]       最后，两个边界位置在left和right越界了，所以单独处理了。
class Solution:
    def multiply(self, A):
        # write code here
        B = A[:]
        B_left = [B[0]]
        B_right = [B[len(B)-1]]
        for i in range(1,len(B)):
            B_left.append(B_left[i-1] * A[i])
            B_right.insert(0,B_right[0] * A[-i-1])
        B[0] = B_right[1]
        B[-1] = B_left[-2]
        for k in range(1,len(B)-1):
            B[k] = B_left[k-1] * B_right[k+1]
        return B

# 41. 二维数组中的查找
# 解法：
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        lis = array[0]
        for i in range(1,len(array)):
            lis += array[i]
        return target in lis

# 42. 扑克牌顺子
# 解法：先排序，然后计算大小王的个数，计算其他牌中间差了几张牌，如果大小王个数大于差值，证明可以顺子。
# 当相同数出现，证明没有顺子。还有，比如2和3，差值为1，但是中间没有空牌，所以计算差值的时候要多减一，所以相等时差值为-1。
class Solution:
    def IsContinuous(self, numbers):
        # write code here
        if not numbers:
            return False
        numbers.sort()
        ghost = 0
        div = 0
        for i in range(len(numbers)-1):
            if numbers[i]==0:
                ghost += 1
            else:
                temp = numbers[i+1] - numbers[i] - 1
                if temp == -1:
                    return False
                div += temp
        if ghost >= div:
            return True
        else:
            return False

# 43. 孩子们的游戏(圆圈中最后剩下的数)
# 解法：主要是序号很迷。 这里定义开始位置为start，第m个就是序号m-1。
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if n<1:
            return -1
        start = 0
        lis = [i for i in range(n)]
        while len(lis)>1:
            k = (start+m-1)%n
            lis.pop(k)
            n -= 1
            start = k
        return lis[0]

# 44.正则表达式匹配
# 解法：按情况一步一步考虑，注释已经很明白了，很牛逼的答案。
class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        # write code here
        # s和pattern都是空的情况
        if len(s) == 0 and len(pattern) == 0:
            return True
        # s不为空但是pattern的情况
        elif len(s) != 0 and len(pattern) == 0:
            return False
        # s为空但是pattern不为空的情况，考虑 * 的影响。
        elif len(s) == 0 and len(pattern) != 0:
            if len(pattern)>1 and pattern[1] == '*':
                return self.match(s, pattern[2:])
            else:
                return False
        # s和pattern都不为空的情况
        else:
            # 如果有*就把*和它前面的元素看为一体，其他情况都一个一个字符判断
            if len(pattern)>1 and pattern[1]=='*':
                # 此时两种情况。1.如果s开头元素和pattern开头元素不同：s不变，pattern跳到*后面继续匹配
                if s[0] != pattern[0] and pattern[0] != '.':
                    return self.match(s, pattern[2:])
                # 2.s和pattern开头相同
                # 这里还要分为三种情况：
                # 第一种：忽略*，后面可能还是相同元素，如果此处和*匹配可能后面就无法匹配了，举个例子：s = 'ab'  pattern='ab*b'\
                # 这时如果b和b*匹配，后面就没有能和b匹配的了，因为*是0-n，这种情况考虑的是*为0的情况。
                # 第二种：s只有一个元素和pattern对上了，表示的是*为1的情况
                # 第三种：s后移一个，pattern不变，表示的是后面可能还有，按照递归去判断下一轮。表示的是*为n>1的情况。
                else:
                    return self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:]) or self.match(s[1:], pattern)
            else:
                if s[0] == pattern[0] or pattern[0] == '.':
                    return self.match(s[1:], pattern[1:])
                else:
                    return False

# 45.表示数值的字符串
# 解法：float()
class Solution:
    # s字符串
    def isNumeric(self, s):
        # write code here
        try:
            float(s)
            return True
        except:
            return False

# 46.字符流中第一个不重复的字符
# 解法：字典，key记字母，values记数。
class Solution:
    # 返回对应char
    def __init__(self):
        self.str = ''
        self.dic = {}
    def FirstAppearingOnce(self):
        # write code here
        for i in self.str:
            if self.dic[i] == 1:
                return i
        return '#'
    def Insert(self, char):
        # write code here
        self.str += char
        if char in self.dic:
            self.dic[char] += 1
        else:
            self.dic[char] = 1

# 47. 替换空格
# 解法：replace
class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        return s.replace(' ', '%20')

# 48. 矩阵中的路径 
# 解法：回溯，注意传入的时候要list变化，保证传入的是新的数组，不会改变原数组的构造。让选过的位置为'0'是因为为了防止再返回走过的路。
# 当时写了二维数组，不能AC，是因为二维数组中的子数组是可变类型，修改为'0'后会使原数组变化，而一维数组因为是list输入的，所以不会变化。
class Solution:
    def hasPath(self, matrix, rows, cols, path):
        # write code here
        for i in range(rows):
            for j in range(cols):
                if matrix[i*cols+j]==path[0]:
                    if self.find(list(matrix),rows,cols,path[1:],i,j):
                        return True
        return False
    def find(self,matrix,rows,cols,path,i,j):
        if not path:
            return True
        matrix[i*cols+j]='0'
        if j+1<cols and matrix[i*cols+(j+1)]==path[0]:
            return self.find(matrix,rows,cols,path[1:],i,j+1)
        elif j-1>=0 and matrix[i*cols+(j-1)]==path[0]:
            return self.find(matrix,rows,cols,path[1:],i,j-1)
        elif i+1<rows and matrix[(i+1)*cols+j]==path[0]:
            return self.find(matrix,rows,cols,path[1:],i+1,j)
        elif i-1>=0 and matrix[(i-1)*cols+j]==path[0]:
            return self.find(matrix,rows,cols,path[1:],i-1,j)
        else:
            return False

# 49. 机器人的运动范围
# 解法：回溯，dfs。 跟上一题十分类似，同样要注意list的问题，下面注释位置的初始化矩阵方式运行不通过，因为*相当于把前面的复制，当改变
# [0][0]时，[1][0] [2][0] [3][0]..  也会同时改变。
# 回溯dfs        常规方法  很多问题都可以基本上差不多的代码解决。
class Solution():
    def movingCount(self, threshold, rows, cols):
        # write code here
        # matrix = [[0] * cols] * rows
        matrix = [[0 for i in range(cols)] for j in range(rows)]
        self.dfs(matrix, threshold, rows, cols, 0, 0)
        return sum(list(map(lambda x:sum(x), matrix)))

    def dfs(self, matrix, threshold, rows, cols, i, j):
        if i<rows and i>=0 and j<cols and j>=0 and self.cal_wei(i, j) <= threshold:
            matrix[i][j] = 1
            if j+1<cols and matrix[i][j+1] != 1:
                self.dfs(matrix, threshold, rows, cols, i, j+1)
            if j-1>=0 and matrix[i][j-1] != 1:
                self.dfs(matrix, threshold, rows, cols, i, j-1)
            if i+1<rows and matrix[i+1][j] != 1:
                self.dfs(matrix, threshold, rows, cols, i+1, j)
            if i-1>=0 and matrix[i-1][j] != 1:
                self.dfs(matrix, threshold, rows, cols, i-1, j)

    def cal_wei(self, i, j):
        return sum(map(lambda x: int(x), list(str(i)))) + sum(map(lambda x: int(x), list(str(j))))

# 递归方法，这个问题适用，每次把当前符合条件的位置置为1，然后查询上下左右四个点是否满足条件。返回值返回自身满足的1加上周围的。
class Solution:
     
    def __init__(self):
        self.vis = {}
         
    def movingCount(self, threshold, rows, cols):
        # write code here
        return self.moving(threshold, rows, cols, 0, 0)
         
    def moving(self, threshold, rows, cols, row, col):
        if row/10 + row%10 + col/10 + col%10 > threshold:
            return 0
        if row >= rows or col >= cols or row < 0 or col < 0:
            return 0
        if (row, col) in self.vis:
            return 0
        self.vis[(row, col)] = 1
         
        return 1 + self.moving(threshold, rows, cols, row-1, col) + self.moving(threshold, rows, cols, row+1, col) + self.moving(threshold, rows, cols, row, col-1) + self.moving(threshold, rows, cols, row, col+1)

# 50. 求1+2+3+…+n
# 解法：递归，f(n)=f(n-1)+n
class Solution:
    def Sum_Solution(self, n):
        # write code here
        if n==1:
            return 1
        return self.Sum_Solution(n-1)+n

# 51. 不用加减乘除实现加法
# 解法：第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。
# 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&111)<<1。
# 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
class Solution:
    def Add(self, num1, num2):
        while num1&num2 != 0:
            num1 = num1 ^ num2
            num2 = num1&num2<<1
        return num1^num2

# 52. 二叉搜索树与双向链表
# 解法：中序遍历是从小到大排序，所以可以先中序遍历存入数组，然后在数组中调整指针指向。还有一种递归解法，没这个简单好理解。
class Solution:
    def Convert(self, pRootOfTree):
        # write code here
        if not pRootOfTree:
            return pRootOfTree
        p = pRootOfTree
        stack = []
        res = []
        while p:
            stack.append(p)
            p = p.left
        while stack:
            node = stack.pop()
            res.append(node)
            right = node.right
            while right:
                stack.append(right)
                right = right.left
        cur = res[0]
        for i in range(len(res)-1):
            res[i].right, res[i+1].left = res[i+1], res[i]
        return cur
# 递归解法：
class Solution:
    def Convert(self, root):
        if not root:
            return None
        if not root.left and not root.right:
            return root
         
        # 将左子树构建成双链表，返回链表头
        left = self.Convert(root.left)
        p = left
         
        # 定位至左子树的最右的一个结点
        while left and p.right:
            p = p.right
         
        # 如果左子树不为空，将当前root加到左子树链表
        if left:
            p.right = root
            root.left = p
         
        # 将右子树构造成双链表，返回链表头
        right = self.Convert(root.right)
        # 如果右子树不为空，将该链表追加到root结点之后
        if right:
            right.left = root
            root.right = right
             
        return left if left else root

# 53. 复杂链表的复制
# 解法：hash法。 定义列表分别存储节点/节点random指针/节点val。 然后查询每个节点的random指针指向第i个节点，新建新的节点，random指针指向
# 刚查询到的第i个指针，最后按照刚存储的节点顺序将next指针指向。
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        # write code here
        randomList = []
        nodeList = []
        nodeval = []
        while pHead:
            randomList.append(pHead.random)
            nodeList.append(pHead)
            nodeval.append(pHead.label)
            pHead = pHead.next
        index = map(lambda x:nodeList.index(x) if x else -1, randomList)
        head = RandomListNode(0)
        pre = head
        node_list = map(lambda x:RandomListNode(x), nodeval)
        for i in range(len(node_list)):
            if index[i] != -1:
                node_list[i].random = node_list[index[i]]
        for j in range(len(node_list)):
            pre.next = node_list[j]
            pre = pre.next
        return head.next

# 54. 字符串的排列
# 解法：dfs。每次选一个，加入到path中，如果list中前面已经出现，就跳过(去除重复)，当原list中为空，证明已经全部选过了，全排列。
def Permutation(self, ss):
    # write code here
    if not ss:
        return []
    def dfs(ss, path, res):
        if len(ss)==0:
            return res.append(path+[])
        for i, x in enumerate(ss):
            if x in ss[:i]:
                continue
            path.append(x)
            dfs(ss[:i]+ss[i+1:], path, res)
            path.pop()
    res = []
    dfs(ss, [], res)
    res_1 = [''.join(i) for i in res]
    # 这里是调整输出格式，由[['a','b','c'],[...]]  -->  ['abc', ...]
    return res_1

# 55.二进制中1的个数 
# 解法：python中，补码用n & 0xffffffff表示，负数转为对应补码的数字，然后当做正数处理。  比如： -5 & 0xffffffff  -->  4294967291
class Solution:
    def NumberOf1(self, n):
        # write code here
        n = n if n>=0 else n & 0xffffffff
        b_nums = bin(n)[2:]
        res = sum(map(lambda x:int(x),list(b_nums)))
        return res

# 56. 倒数第k个节点
# 解法：定义p,q两个节点，让p和q之间的距离是k，那么当q为结尾时，p就是倒数第k个。
class Solution:
    def FindKthToTail(self, head, k):
        # write code here
        fir = sec = head
        for i in range(k):
            if fir==None:
                return None
            fir = fir.next
        while fir:
            fir = fir.next
            sec = sec.next
        return sec

# 57. 合并两个排序的链表
# 解法：节点比较大小，接入新的链表中。
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        mergeHead = ListNode(1111)
        p = mergeHead
        while pHead1 and pHead2:
            if pHead1.val > pHead2.val and pHead2.next:
                mergeHead.next = pHead2
                pHead2 = pHead2.next
            else:
                mergeHead.next = pHead1
                pHead1 = pHead1.next
            mergeHead = mergeHead.next
        if pHead1:
            mergeHead.next = pHead1
        elif pHead2:
            mergeHead.next = pHead2
        return p.next

# 58. 反转链表
# 解法：定义三个指针，当最右指针下一个为空，证明最右为尾指针，直接指向前面就可以了，中间过程就是迭代。
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead == None:
            return None
        pre, cur, behind = None, None, pHead
        while behind.next:
            pre = cur
            cur = behind
            behind = behind.next
            cur.next = pre
        behind.next = cur
        return behind

# 59. 树的子结构
# 解法：root2可能是root1，可能在root1的左，可能在root1的右。在判断root1和root2相等的时候，先写root2为不为空，如果为空，证明root2的内容
# root1中都有。如果先写root1判断，那么可能root1和root2同时为空，应该是相等的，判断就会出错。
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        if not pRoot1 or not pRoot2:
            return False
        return self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right,pRoot2) or self.issub(pRoot1, pRoot2)
    def issub(self, pRoot1, pRoot2):
        if not pRoot2:
            return True
        if not pRoot1 or pRoot1.val != pRoot2.val:
            return False
        return self.issub(pRoot1.left, pRoot2.left) and self.issub(pRoot1.right, pRoot2.right)

# 60. 数值的整数次方
# 解法：pow()函数
def Power(self, base, exponent):
    # write code here
    return pow(base, exponent)

# 61. 调整数组顺序使奇数位于偶数前面
# 解法：开辟新空间。     不开批空间的话用排序吗？
class Solution:
    def reOrderArray(self, array):
        # write code here
        odd = []
        even = []
        for i in array:
            if i%2==0:
                even.append(i)
            else:
                odd.append(i)
        res = odd + even
        return res

# 62. 包含min函数的栈
# 解法：题目是要存储每个时刻的栈中存在的最小值，入栈的同时计算最小的是多少，然后存到min栈中。当stack出栈时，minstack对应的也出栈。
class Solution:
    def __init__(self):
        self.stack = []
        self.minstack = []
    def push(self, node):
        # write code here
        self.stack.append(node)
        if len(self.minstack)==0:
            self.minstack.append(node)
        else:
            if node<self.minstack[-1]:
                self.minstack.append(node)
            else:
                self.minstack.append(self.minstack[-1])
    def pop(self):
        # write code here
        self.stack.pop()
        self.minstack.pop()
    def top(self):
        # write code here
        return self.stack[-1]
    def min(self):
        # write code here
        return self.minstack[-1]

# 63. 二叉树中和为某一值的路径
# 解法：dfs，注意path[:]，还有就是没有返回值  需要思考一下。
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        res = []
        def dfs(root, nums, path):
            if root:
                if root.left == None and root.right == None:
                    if root.val==nums:
                        path.append(root.val)
                        res.append(path[:])
                else:
                    path.append(root.val)
                    dfs(root.left, nums - root.val, path[:])
                    dfs(root.right, nums - root.val, path[:])
        dfs(root,expectNumber, [])
        return res

# 64. 从上往下打印二叉树
# 解法：层序遍历，广度优先搜索。
class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    def PrintFromTopToBottom(self, root):
        # write code here
        if not root:
            return []
        node = [root]
        res = []
        while node:
            cur = node.pop(0)
            res.append(cur.val)
            if cur.left:
                node.append(cur.left)
            if cur.right:
                node.append(cur.right)
        return res

# 65. 二叉搜索树的后序遍历序列
# 解法：最后一个节点是根节点，根节点比左边大，比右边小。
# -*- coding:utf-8 -*-
class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if len(sequence)==0:
            return False
        root = sequence[-1]
        i = 0
        for node in sequence[:-1]:
            if node > root:
                break
            i += 1
        for node in sequence[i:-1]:
            if node < root:
                return False
        left_s = sequence[:i]
        right_s = sequence[i:-1]

        left = True if len(left_s) > 0 else left = self.VerifySquenceOfBST(left_s)
        right = True if len(right_s) > 0 else right = self.VerifySquenceOfBST(right_s)
        return left and right

# 66. 栈的压入、弹出序列
# 解法：创建一个新栈，按照压栈顺序压栈，在压栈过程中，如果遇到出栈元素就出栈，出栈后继续判断是否下一个出栈元素还在栈顶，如果在就
# 继续出栈，如果不在就接着压栈，最后如果栈为空，就证明这个出栈顺序可以，如果不为空就证明出栈顺序不对。
class Solution:
    def IsPopOrder(self, pushV, popV):
        # write code here
        if not pushV:
            return False
        stack = []
        for i in pushV:
            stack.append(i)
            while len(stack) and popV[0] == stack[-1]:
                stack.pop()
                popV.pop(0)
        if len(stack):
            return False
        return True


# 华为研发工程师编程题
1.
#有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？
#”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候
#剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，
#最多可以换多少瓶汽水喝？ 

#输入描述:
#输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。

#输出描述:
#对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。

#输入例子1:
#3
#10
#81
#0

#输出例子1:
#1
#5
#40

lines=[]
while True:
    try:
        lines.append(int(input()))
    except:
        resss = []
        for nums in lines:
            res = 0
            if nums<2:
                resss.append(0)
                continue
            while nums>2:
                res += nums//3
                nums = nums%3 + nums//3
            if nums == 2:
                resss.append(res+1)
            else:
                resss.append(res)
        for i in resss:
            print(i)
        break


2.
# 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重
# 复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做
# 调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。

# Input Param
# n               输入随机数的个数
# inputArray      n个随机整数组成的数组

# Return Value
# OutputArray    输出处理后的随机整数

# 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。

# 输入描述:
# 输入多行，先输入随机整数的个数，再输入相应个数的整数

# 输出描述:
# 返回多行，处理后的结果

# 输入例子1:
# 11
# 10
# 20
# 40
# 32
# 67
# 40
# 20
# 89
# 300
# 400
# 15

# 输出例子1:
# 10
# 15
# 20
# 32
# 40
# 67
# 89
# 300
# 400


# -*-coding:utf8-*-
 
# 用空格获取输入数据的两种方法， map()的返回值是一个迭代器
# num1 = list(map(int, input().strip().split()))
# num2 = [int(temp) for temp in input().split()]

lines = []
while True:
    try:
        lines.append(int(input()))
    except:
        res = []
        i = 0
        while i<len(lines):
            test_no = lines[i]
            temp_list = lines[i+1:test_no+1+i]
            temp_list = list(set(temp_list))
            temp_list.sort()
            res += temp_list
            i += test_no+1
        for i in res:
            print(i)
        break


3. 给定一列非负整数，求这些数连接起来能组成的最大的数。
# 第一行n>0是一个正整数，表示一共有n个输入。以后每行是一个非负整数，共有n行。
lines = []
while True:
    try:
        lines.append(input())
    except:
        lines = lines[1:]
        length = len(lines)
        for i in range(length-1):
            for j in range(length-1-i):
                cmp_1 = lines[j]+lines[j+1]
                cmp_2 = lines[j+1]+lines[j]
                if int(cmp_2)>int(cmp_1):
                    lines[j], lines[j+1] = lines[j+1], lines[j]
        res = ''
        for k in lines:
            res += k
        print(int(res))
        break

4. M×N的矩阵，从左上角走，只能向右或者向下走，要求走过的每个元素的值加起来的和最大，步数不限
# 解法：创建一个新的同样大小的矩阵，计算并保存每一个点可能的最大值是多少，最后输出最大的值。
# 比如，新矩阵[1,1]位置的最大值必然是[1,1]+[0,1](即本身的值加上它上边的值)或者[1,1]+[1,0](即本身的值加上它左边的值)
import numpy as np
def max_way(a, m, n):
    dp = [[0] * n for i in range(m)]
    dp[0][0] = a[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + a[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + a[0][j]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = max(dp[i - 1][j] + a[i][j], dp[i][j - 1] + a[i][j])
    # print(dp)
    # 求矩阵中元素的最大值
    ls = []
    for i in range(m):
        ls.append(max(dp[i]))

    return max(ls)

a = [[2, 5, 6, 4], [5, 8, 7, 3], [9, 5, 1, 4]]
# 不使用numpy
# =============================================================================
# print(len(a))#行数
# print(len(a[0]))#列数
# #使用numpy
# row=np.shape(a)[0]#求矩阵的行数
# col=np.shape(a)[1]#求矩阵的列数
# print(row,col)
# =============================================================================
print(max_way(a, 3, 4))

5.已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。  LeetCode.688
 N 表示棋盘的长宽      K表示行走的步数        r,c 表示初始的位置
# 解法：计算的是每一步到每个点的概率，比如第一步时，p是1，移动后新位置如果在棋盘中，他的位置就是xx,yy，概率就是p*0.125
# 如果不在棋盘中，那他的概率就加在out的概率中。  经过第一步后得到可能所处的点和在这个点的概率，然后用这个代替第一步的d，
# 重新temp={}，继续计算这些点中每个点移动到其他点的概率。如果多个点都移动到一个点了，那么移动到这个点的概率应该是多个点移动到这个点概率的和。
class Solution:
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        if K==0:
            return 1.0
        go=[(2,1),(2,-1),(1,2),(1,-2),(-2,1),(-2,-1),(-1,2),(-1,-2)]
        d={(r,c):1}
        out=0
        for _ in range(K):
            temp={}
            for (x,y),p in d.items():
                for d in go:
                    xx,yy=x+d[0],y+d[1]
                    if 0<=xx<N and 0<=yy<N:
                        temp[(xx,yy)]=temp.get((xx,yy),0)+p*0.125
                        # 这里是为了解决多个步都移动到xx,yy点，那么xx,yy点的概率就应该是之前的概率加上这一次移动到这的概率
                    else:
                        out+=p*0.125
            d=temp
        return 1-out

6. 写一个power(a,n)
# 解法1： 递归
def power(a,n):
    if n==0:
        return 1
    res = a * power(a, n-1)
    return res
# 解法2：快速幂
# 思路：当n为偶数时，a^n==(a^2)^(n/2)        当n为奇数时，a^n=[(a^2)^(n/2)]*a
# 因此可以迭代的进行这样的操作，比如a=2,n=5,迭代a=4,n=2,迭代a=16，n=1.    n>>1 表示右移一位，相当于除2
def quick(a, n):
    res = 1
    while n>0:
        if n%2==1:
            res *= a
        a = a*a
        n = n >> 1
    return res

7. 二叉树节点总数
# 解法：递归。 任务：计算左右子树的节点个数。    返回值：左子树节点个数+右子树节点个数+1(自身)   终止条件:节点为None
def nums_of_node(self, root):
    if root is None:
        return 0 
    left = nums_of_node(root.left)
    right = nums_of_node(root.right)
    return left+right+1

8. 完全二叉树的最后一个节点
# 解法：先广度优先搜索，得到完全二叉树广度遍历的list。如果二叉树的节点个数是已知的为N，则不断除以2，记录奇偶性，然后反过来
# 从根出发，偶则向左，奇则向右，一直到底就找到了。时间复杂度O(logN)，例如，如果N=9,则奇偶性是[奇、偶、偶]反过来从根节点就是左->左->右
def breadth_search(root):
    if root is None:
        return 
    queue = [root]
    N = 1
    while queue:
        cur = queue.pop(0)
        if cur.lchild is not None:
            queue.append(cur.lchild)
            N += 1
        if cur.rchild is not None:
            queue.append(cur.rchild)
            N += 1
    return N

def last_node(N, head):
    ord = []
    while N>1:
        if N%2==0:
            ord.append(0)
        else:
            ord.append(1)
        N //= 2
    while ord:
        dire = ord.pop()
        head = head.lchild if dire==0 else head.rchild
    return head

9. 二叉树最近公共祖先(LCA)
# 解法：如果两个目标点，一个在当前点的左子树，一个在当前点的右子树，就证明当前点是最近的公共祖先。
def lowestCommonAncestor(self, root, A, B):
    if root is None or root==A or root==B:
        return root     # 证明当前点是A或者B或者空
    left = lowestCommonAncestor(root.lchild, A, B)
    right = lowestCommonAncestor(root.rchild, A, B)
    if left and right:
        return root     # 如果左右都不是None，证明AB在当前节点的一个左一个右
    if not left:
        return right
    if not right:       # 如果右边为None，证明左边找到了，就把找到的点返回。
        return left
    return None

# 任意两点之间的距离：通过广度搜索将节点存入list，将要计算的两个节点的index+1(意思是从1开始)分别计算二进制数，二进制数的位数就是层数。

10. 求数的所有质因子
# 解法：从2开始遍历，只要遇到的数是可以整除的就是需要的质数，因为在后面如果遇到合数，那这个合数的质因子之前一定已经被除了。
def all_divisors(number):
    res_list = []
    while number!=1:
        for i in range(2,number+1):
            if number%i==0:
                res_list.appende(i)
                break
    return res_list

11. 大数取余
# 解法：对于很大的数字取余数，可以将每一位的数取余，余数*10+下一位再继续取余，直到最后一位，结果就是余数的结果。
def yu(nums, yushu):
    if nums<10:
        return nums%yushu
    strs = str(nums)
    temp = int(strs[0])%yushu
    for i in strs[1:]:
        temp = (temp*10 + int(i))%yushu
    print(temp)

12. 比较两个版本字符串version1和version2   bilibili2019秋招技术岗(算法)第一套笔试卷
# 如果version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.
# 输入的version字符串非空，只包含数字和字符.。.字符不代表通常意义上的小数点，只是用来区分数字序列。例如字符串2.5并不代表二点五，只是代表
# 版本是第一级版本号是2，第二级版本号是5.

# 0.1 1.1       输入例子
# -1            输出例子

# 3.3.3  3.3.3.1    输入例子
# -1                输出例子

data_in = [x for x in input().split()]
version_1, version_2 = data_in[0].split('.'), data_in[1].split('.')
length = len(version_1) if len(version_1)<len(version_2) else len(version_2)
for i in range(length):
    if int(version_1[i])>int(version_2[i]):
        print(1)
        break
    elif int(version_1[i])<int(version_2[i]):
        print(-1)
        break
    else:
        if i == length-1:
            if len(version_1)==len(version_2):
                print(0)
            elif len(version_1)>len(version_2):
                print(1)
            else:
                print(-1)
                
# 还有一种方法，短的list补0使得和长的一样长，这样就不用在else再判断len(version)了。

13. 给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：
区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列[6 2 1], 可得到所有可以选定各个区间的计算值:
[6] = 6 * 6 = 36;
[2] = 2 * 2 = 4;
[1] = 1 * 1 = 1;
[6,2] = 2 * 8 = 16;
[2,1] = 1 * 3 = 3;
[6, 2, 1] = 1 * 9 = 9;
从上述计算可见选定区间 [6] ，计算值为 36， 则程序输出为 36。
区间内的所有数字都在[0, 100]的范围内;
# 可以双循环暴力，20%。  
# 下面是把list中的每个数都当做最小值，然后向左右寻找不小于它的数，然后计算。 50%
length = int(input())
lis = [int(i) for i in input().split()]
max_cal = -1
for i in range(length):
    left, right = i, i
    while left>=0:
        if lis[left]<lis[i]:
            break
        left -= 1
    while right<length:
        if lis[right]<lis[i]:
            break
        right += 1
    temp = lis[i] * sum(lis[left+1:right])
    max_cal = temp if temp>max_cal else max_cal
print(max_cal)
# 下面是考虑最小值在[0,100]区间，所以把最小值循环。
# 输入的数组为 55，65，45,30，75，65，54,,33,67，83
# 现在规定区间的最小值要大于50（代码中第一个for循环的j），所以扫描一遍数组（第二个for循环）
# 发现每个满足大于50并且能达到的最长区间只有55，65这个区间和75,65，54这个区间和67,83这个区间，这三个区间满足条件，然后进行比较解答出ans。
# 一直循环。。。到最小值大于等于0，不断更新ans就可以了


14.  给定一个二维数组[[1,2,3,4,5],[11,12,13,14,15],[21,22,23,24,25],[31,32,33,34,35],[41,42,43,44,45]],输入一个有六个元素的列表
比如1 2 3 4 5 11，求这6个元素是否相连，相连输出1，不相连输出0，输入行数不限。
例如输入：1 2 3 4 5 11
          1 2 11 14 25 15
对应输出：
1
0
# 注意这个输入的顺序，开头可能是中间位置，所以不能用48题的方法。这里的方法是先建立同等大小的全0矩阵，在目标位置设为1，
# 然后从最小的开始进行dfs，每个是1的点置位0在递归，外面num是计数的，当num为1时，证明所有的1都是连着的。
import sys
from numpy import *
def dfs(arr,i,j):
    arr[i][j]=0
    if i-1>=0 and arr[i-1][j]==1:
        dfs(arr,i-1,j)
    if i+1<=4 and arr[i+1][j]==1:
        dfs(arr,i+1,j)
    if j-1>=0 and arr[i][j-1]==1:
        dfs(arr,i,j-1)
    if j+1<=4 and arr[i][j+1]==1:
        dfs(arr,i,j+1)
 
def island(lista):
    arr = zeros([5, 5], int）
    for item in lista:
        row = item / 10
        col = item - 10 * row - 1
        arr[row][col] = 1
    num = 0
    for i in range(5):
        for j in range(5):
            if arr[i][j]==1:
                num+=1
                dfs(arr,i,j)
    if num==1:
        return 1
    else:
        return 0
 
lines=sys.stdin.readlines()
for line in lines:
    lista=line.strip()
    lista = map(int, lista.split())
    answer=island(lista)
    print answer

15. LIS最长上升子序列
# 如(1, 7, 9), (3, 4, 8), (1, 3, 5, 8)等等，而这些子序列中最长的（如子序列(1, 3, 5, 8) ），它的长度为4，因此该序列的最长上升子序列长度为4。
# 子序列是可以不连续的，子串是连续的。
# 我们要求n个数的最长上升子序列，可以求前n-1个数的最长上升子序列，再跟第n个数进行判断。求前n-1个数的最长上升子序列，可以通过求前n-2个数的最
# 长上升子序列……直到求前1个数的最长上升子序列，此时LIS当然为1。
让我们举个例子：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。
前1个数 d(1)=1 子序列为2；
前2个数 7前面有2小于7 d(2)=d(1)+1=2 子序列为2 7
前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d(3)=1 子序列为1
前4个数 5前面有2小于5 d(4)=d(1)+1=2 子序列为2 5
前5个数 6前面有2 5小于6 d(5)=d(4)+1=3 子序列为2 5 6
前6个数 4前面有2小于4 d(6)=d(1)+1=2 子序列为2 4
前7个数 3前面有2小于3 d(3)=d(1)+1=2 子序列为2 3
前8个数 8前面有2 5 6小于8 d(8)=d(5)+1=4 子序列为2 5 6 8
前9个数 9前面有2 5 6 8小于9 d(9)=d(8)+1=5 子序列为2 5 6 8 9
d(i)=max{d(1),d(2),……,d(i)} 我们可以看出这9个数的LIS为d(9)=5
# 找出每个位置的最长子序列，每个位置最小是1(只有自己)，或者是它的上一个子序列值的子序列个数+1。
a = [1,7,3,5,9,4,8]
b = [1 for i in range(len(a))]
for i in range(1,len(a)):
    count = 0
    for j in range(i-1,-1,-1):
        if a[j]<a[i]:
            b[i] = b[j] + 1
            break
print(b)

16. 最长递增子串：
# 类似上一道题想到的，最长子串，更简单一些，只用考虑自身的上一个的大小，然后决定是1或者是上一个的+1。
a = [1,3,6,4,2,6,4,8,6,9,7,4,1,5,6,7,4,3]
b = [0 for i in range(len(a))]
b[0] = 1
for i in range(1,len(a)):
    if a[i]>a[i-1]:
        b[i] = b[i-1] + 1
    else:
        b[i] = 1
print(b)

17. 最大子串和
# 每次都把节点当成结尾节点，后面的节点是前面的求和，如果前面的求和小于0，那么就从自身开始。
list_in = [-2,1,-3,4,-1,2,1,-5,4]
sum_cal = list_in[0]
max_add = list_in[0]
for i in range(1,len(list_in)):
    if sum_cal<0:
        sum_cal = list_in[i]
    else:
        sum_cal += list_in[i]
    if sum_cal>max_add:
        max_add = sum_cal
# 这几道题都是动态规划的思路解，动态规划就是把问题拆分，特点就是当前解可以由上一阶段解推出。
# 两种都是考虑当前节点和前一个，要么if条件是等于1，要么if条件是等于自身。
        
18. 哈弗曼树：   https://blog.csdn.net/qq_29519041/article/details/81428934

